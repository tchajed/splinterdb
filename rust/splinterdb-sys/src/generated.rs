/* automatically generated by rust-bindgen 0.60.1 */

pub const MAX_KEY_SIZE: u32 = 105;
pub const SPLINTERDB_MAX_KEY_SIZE: u32 = 104;
pub type size_t = ::std::os::raw::c_ulong;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type int32 = i32;
pub type uint32 = u32;
pub type uint64 = u64;
pub type bool_ = int32;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice {
    pub length: uint64,
    pub data: *const ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_slice() {
    assert_eq!(
        ::std::mem::size_of::<slice>(),
        16usize,
        concat!("Size of: ", stringify!(slice))
    );
    assert_eq!(
        ::std::mem::align_of::<slice>(),
        8usize,
        concat!("Alignment of ", stringify!(slice))
    );
    fn test_field_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<slice>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(slice),
                "::",
                stringify!(length)
            )
        );
    }
    test_field_length();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<slice>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(slice),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
pub const message_type_MESSAGE_TYPE_INVALID: message_type = 0;
pub const message_type_MESSAGE_TYPE_INSERT: message_type = 1;
pub const message_type_MESSAGE_TYPE_UPDATE: message_type = 2;
pub const message_type_MESSAGE_TYPE_DELETE: message_type = 3;
pub const message_type_MESSAGE_TYPE_MAX_VALID_USER_TYPE: message_type = 3;
pub const message_type_MESSAGE_TYPE_PIVOT_DATA: message_type = 1000;
pub type message_type = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct message {
    pub type_: message_type,
    pub data: slice,
}
#[test]
fn bindgen_test_layout_message() {
    assert_eq!(
        ::std::mem::size_of::<message>(),
        24usize,
        concat!("Size of: ", stringify!(message))
    );
    assert_eq!(
        ::std::mem::align_of::<message>(),
        8usize,
        concat!("Alignment of ", stringify!(message))
    );
    fn test_field_type() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<message>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(message),
                "::",
                stringify!(type_)
            )
        );
    }
    test_field_type();
    fn test_field_data() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<message>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(message),
                "::",
                stringify!(data)
            )
        );
    }
    test_field_data();
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct merge_accumulator {
    _unused: [u8; 0],
}
pub type key_compare_fn = ::std::option::Option<
    unsafe extern "C" fn(
        cfg: *const data_config,
        key1: slice,
        key2: slice,
    ) -> ::std::os::raw::c_int,
>;
pub type key_hash_fn = ::std::option::Option<
    unsafe extern "C" fn(
        input: *const ::std::os::raw::c_void,
        length: size_t,
        seed: uint32,
    ) -> uint32,
>;
pub type merge_tuple_fn = ::std::option::Option<
    unsafe extern "C" fn(
        cfg: *const data_config,
        key: slice,
        old_message: message,
        new_message: *mut merge_accumulator,
    ) -> ::std::os::raw::c_int,
>;
pub type merge_tuple_final_fn = ::std::option::Option<
    unsafe extern "C" fn(
        cfg: *const data_config,
        key: slice,
        oldest_message: *mut merge_accumulator,
    ) -> ::std::os::raw::c_int,
>;
pub type key_to_str_fn = ::std::option::Option<
    unsafe extern "C" fn(
        cfg: *const data_config,
        key: slice,
        str_: *mut ::std::os::raw::c_char,
        max_len: uint64,
    ),
>;
pub type message_to_str_fn = ::std::option::Option<
    unsafe extern "C" fn(
        cfg: *const data_config,
        msg: message,
        str_: *mut ::std::os::raw::c_char,
        max_len: uint64,
    ),
>;
#[repr(C)]
#[derive(Debug)]
pub struct data_config {
    pub key_size: uint64,
    pub min_key: [::std::os::raw::c_char; 105usize],
    pub min_key_length: uint64,
    pub max_key: [::std::os::raw::c_char; 105usize],
    pub max_key_length: uint64,
    pub key_compare: key_compare_fn,
    pub key_hash: key_hash_fn,
    pub merge_tuples: merge_tuple_fn,
    pub merge_tuples_final: merge_tuple_final_fn,
    pub key_to_string: key_to_str_fn,
    pub message_to_string: message_to_str_fn,
}
#[test]
fn bindgen_test_layout_data_config() {
    assert_eq!(
        ::std::mem::size_of::<data_config>(),
        296usize,
        concat!("Size of: ", stringify!(data_config))
    );
    assert_eq!(
        ::std::mem::align_of::<data_config>(),
        8usize,
        concat!("Alignment of ", stringify!(data_config))
    );
    fn test_field_key_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key_size) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(key_size)
            )
        );
    }
    test_field_key_size();
    fn test_field_min_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_key) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(min_key)
            )
        );
    }
    test_field_min_key();
    fn test_field_min_key_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).min_key_length) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(min_key_length)
            )
        );
    }
    test_field_min_key_length();
    fn test_field_max_key() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_key) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(max_key)
            )
        );
    }
    test_field_max_key();
    fn test_field_max_key_length() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_key_length) as usize - ptr as usize
            },
            240usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(max_key_length)
            )
        );
    }
    test_field_max_key_length();
    fn test_field_key_compare() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key_compare) as usize - ptr as usize
            },
            248usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(key_compare)
            )
        );
    }
    test_field_key_compare();
    fn test_field_key_hash() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key_hash) as usize - ptr as usize
            },
            256usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(key_hash)
            )
        );
    }
    test_field_key_hash();
    fn test_field_merge_tuples() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).merge_tuples) as usize - ptr as usize
            },
            264usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(merge_tuples)
            )
        );
    }
    test_field_merge_tuples();
    fn test_field_merge_tuples_final() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).merge_tuples_final) as usize - ptr as usize
            },
            272usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(merge_tuples_final)
            )
        );
    }
    test_field_merge_tuples_final();
    fn test_field_key_to_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).key_to_string) as usize - ptr as usize
            },
            280usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(key_to_string)
            )
        );
    }
    test_field_key_to_string();
    fn test_field_message_to_string() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<data_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).message_to_string) as usize - ptr as usize
            },
            288usize,
            concat!(
                "Offset of field: ",
                stringify!(data_config),
                "::",
                stringify!(message_to_string)
            )
        );
    }
    test_field_message_to_string();
}
extern "C" {
    pub fn splinterdb_get_version() -> *const ::std::os::raw::c_char;
}
#[repr(C)]
#[derive(Debug)]
pub struct splinterdb_config {
    pub filename: *const ::std::os::raw::c_char,
    pub cache_size: uint64,
    pub disk_size: uint64,
    pub data_cfg: *mut data_config,
    pub heap_handle: *mut ::std::os::raw::c_void,
    pub heap_id: *mut ::std::os::raw::c_void,
    pub page_size: uint64,
    pub extent_size: uint64,
    pub io_flags: ::std::os::raw::c_int,
    pub io_perms: uint32,
    pub io_async_queue_depth: uint64,
    pub cache_use_stats: bool_,
    pub cache_logfile: *const ::std::os::raw::c_char,
    pub btree_rough_count_height: uint64,
    pub filter_remainder_size: uint64,
    pub filter_index_size: uint64,
    pub use_log: bool_,
    pub memtable_capacity: uint64,
    pub fanout: uint64,
    pub max_branches_per_node: uint64,
    pub use_stats: uint64,
    pub reclaim_threshold: uint64,
}
#[test]
fn bindgen_test_layout_splinterdb_config() {
    assert_eq!(
        ::std::mem::size_of::<splinterdb_config>(),
        168usize,
        concat!("Size of: ", stringify!(splinterdb_config))
    );
    assert_eq!(
        ::std::mem::align_of::<splinterdb_config>(),
        8usize,
        concat!("Alignment of ", stringify!(splinterdb_config))
    );
    fn test_field_filename() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filename) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(filename)
            )
        );
    }
    test_field_filename();
    fn test_field_cache_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache_size) as usize - ptr as usize
            },
            8usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(cache_size)
            )
        );
    }
    test_field_cache_size();
    fn test_field_disk_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).disk_size) as usize - ptr as usize
            },
            16usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(disk_size)
            )
        );
    }
    test_field_disk_size();
    fn test_field_data_cfg() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).data_cfg) as usize - ptr as usize
            },
            24usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(data_cfg)
            )
        );
    }
    test_field_data_cfg();
    fn test_field_heap_handle() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heap_handle) as usize - ptr as usize
            },
            32usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(heap_handle)
            )
        );
    }
    test_field_heap_handle();
    fn test_field_heap_id() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).heap_id) as usize - ptr as usize
            },
            40usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(heap_id)
            )
        );
    }
    test_field_heap_id();
    fn test_field_page_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).page_size) as usize - ptr as usize
            },
            48usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(page_size)
            )
        );
    }
    test_field_page_size();
    fn test_field_extent_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).extent_size) as usize - ptr as usize
            },
            56usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(extent_size)
            )
        );
    }
    test_field_extent_size();
    fn test_field_io_flags() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_flags) as usize - ptr as usize
            },
            64usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(io_flags)
            )
        );
    }
    test_field_io_flags();
    fn test_field_io_perms() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_perms) as usize - ptr as usize
            },
            68usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(io_perms)
            )
        );
    }
    test_field_io_perms();
    fn test_field_io_async_queue_depth() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).io_async_queue_depth) as usize - ptr as usize
            },
            72usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(io_async_queue_depth)
            )
        );
    }
    test_field_io_async_queue_depth();
    fn test_field_cache_use_stats() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache_use_stats) as usize - ptr as usize
            },
            80usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(cache_use_stats)
            )
        );
    }
    test_field_cache_use_stats();
    fn test_field_cache_logfile() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).cache_logfile) as usize - ptr as usize
            },
            88usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(cache_logfile)
            )
        );
    }
    test_field_cache_logfile();
    fn test_field_btree_rough_count_height() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).btree_rough_count_height) as usize - ptr as usize
            },
            96usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(btree_rough_count_height)
            )
        );
    }
    test_field_btree_rough_count_height();
    fn test_field_filter_remainder_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filter_remainder_size) as usize - ptr as usize
            },
            104usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(filter_remainder_size)
            )
        );
    }
    test_field_filter_remainder_size();
    fn test_field_filter_index_size() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).filter_index_size) as usize - ptr as usize
            },
            112usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(filter_index_size)
            )
        );
    }
    test_field_filter_index_size();
    fn test_field_use_log() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).use_log) as usize - ptr as usize
            },
            120usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(use_log)
            )
        );
    }
    test_field_use_log();
    fn test_field_memtable_capacity() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).memtable_capacity) as usize - ptr as usize
            },
            128usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(memtable_capacity)
            )
        );
    }
    test_field_memtable_capacity();
    fn test_field_fanout() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).fanout) as usize - ptr as usize
            },
            136usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(fanout)
            )
        );
    }
    test_field_fanout();
    fn test_field_max_branches_per_node() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).max_branches_per_node) as usize - ptr as usize
            },
            144usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(max_branches_per_node)
            )
        );
    }
    test_field_max_branches_per_node();
    fn test_field_use_stats() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).use_stats) as usize - ptr as usize
            },
            152usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(use_stats)
            )
        );
    }
    test_field_use_stats();
    fn test_field_reclaim_threshold() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_config>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).reclaim_threshold) as usize - ptr as usize
            },
            160usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_config),
                "::",
                stringify!(reclaim_threshold)
            )
        );
    }
    test_field_reclaim_threshold();
}
#[repr(C)]
#[derive(Debug)]
pub struct splinterdb {
    _unused: [u8; 0],
}
extern "C" {
    pub fn splinterdb_create(
        cfg: *const splinterdb_config,
        kvs: *mut *mut splinterdb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn splinterdb_open(
        cfg: *const splinterdb_config,
        kvs: *mut *mut splinterdb,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn splinterdb_close(kvs: *mut *mut splinterdb);
}
extern "C" {
    pub fn splinterdb_register_thread(kvs: *mut splinterdb);
}
extern "C" {
    pub fn splinterdb_deregister_thread(kvs: *mut splinterdb);
}
extern "C" {
    pub fn splinterdb_insert(
        kvsb: *const splinterdb,
        key: slice,
        value: slice,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn splinterdb_delete(kvsb: *const splinterdb, key: slice) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn splinterdb_update(
        kvsb: *const splinterdb,
        key: slice,
        delta: slice,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[repr(align(8))]
#[derive(Debug)]
pub struct splinterdb_lookup_result {
    pub opaque: [::std::os::raw::c_char; 48usize],
}
#[test]
fn bindgen_test_layout_splinterdb_lookup_result() {
    assert_eq!(
        ::std::mem::size_of::<splinterdb_lookup_result>(),
        48usize,
        concat!("Size of: ", stringify!(splinterdb_lookup_result))
    );
    assert_eq!(
        ::std::mem::align_of::<splinterdb_lookup_result>(),
        8usize,
        concat!("Alignment of ", stringify!(splinterdb_lookup_result))
    );
    fn test_field_opaque() {
        assert_eq!(
            unsafe {
                let uninit = ::std::mem::MaybeUninit::<splinterdb_lookup_result>::uninit();
                let ptr = uninit.as_ptr();
                ::std::ptr::addr_of!((*ptr).opaque) as usize - ptr as usize
            },
            0usize,
            concat!(
                "Offset of field: ",
                stringify!(splinterdb_lookup_result),
                "::",
                stringify!(opaque)
            )
        );
    }
    test_field_opaque();
}
extern "C" {
    pub fn splinterdb_lookup_result_init(
        kvs: *const splinterdb,
        result: *mut splinterdb_lookup_result,
        buffer_len: uint64,
        buffer: *mut ::std::os::raw::c_char,
    );
}
extern "C" {
    pub fn splinterdb_lookup_result_deinit(result: *mut splinterdb_lookup_result);
}
extern "C" {
    pub fn splinterdb_lookup_found(result: *const splinterdb_lookup_result) -> bool_;
}
extern "C" {
    pub fn splinterdb_lookup_result_value(
        result: *const splinterdb_lookup_result,
        value: *mut slice,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn splinterdb_lookup(
        kvs: *const splinterdb,
        key: slice,
        result: *mut splinterdb_lookup_result,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug)]
pub struct splinterdb_iterator {
    _unused: [u8; 0],
}
extern "C" {
    pub fn splinterdb_iterator_init(
        kvs: *const splinterdb,
        iter: *mut *mut splinterdb_iterator,
        start_key: slice,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn splinterdb_iterator_deinit(iter: *mut splinterdb_iterator);
}
extern "C" {
    pub fn splinterdb_iterator_valid(iter: *mut splinterdb_iterator) -> bool_;
}
extern "C" {
    pub fn splinterdb_iterator_next(iter: *mut splinterdb_iterator);
}
extern "C" {
    pub fn splinterdb_iterator_get_current(
        iter: *mut splinterdb_iterator,
        key: *mut slice,
        value: *mut slice,
    );
}
extern "C" {
    pub fn splinterdb_iterator_status(iter: *const splinterdb_iterator) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn default_data_config_init(max_key_size: uint64, out_cfg: *mut data_config);
}
